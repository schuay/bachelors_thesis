%%
%% Design Approach
%%
%% This file should be edited by user
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{simavr Internals} \label{chapter:simavr}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

It is necessary to understand simavr's internals before going on to discuss
qsimavr's design.

simavr is a small cross-platform AVR simulator written with simplicity and
hackability in mind. It is supported on Linux and OS X, but should run on any
platform with avr-libc support.

In the following sections, we will take a tour through simavr internals\footnote{
Most, if not all of the code examined in this chapter is taken directly from simavr.}.
Without further delay, let's jump right in and walk through a short demo.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{simavr Example Walkthrough}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The following program is taken from the board\_i2ctest simavr example. Minor
modifications have been made to focus on the essential section. Error handling
is mostly omitted in favor of readability.

\begin{lstlisting}
#include <stdlib.h>
#include <stdio.h>
#include <libgen.h>
#include <pthread.h>

#include "sim_avr.h"
#include "avr_twi.h"
#include "sim_elf.h"
#include "sim_gdb.h"
#include "sim_vcd_file.h"
#include "i2c_eeprom.h"
\end{lstlisting}

The actual simulation of the external EEPROM component is located in
i2c\_eeprom.h. We will take a look at the implementation later on.

\begin{lstlisting}
avr_t * avr = NULL;
avr_vcd_t vcd_file;

i2c_eeprom_t ee;
\end{lstlisting}

avr is the main data structure. It encapsulates the entire state of the
core simulation, including register, SRAM and flash contents, the CPU state, the
current cycle count, callbacks for various tasks, pending interrupts, and more.

\lstinline|vcd_file| represents the file target for the \emph{value change dump} module. It
is used to dump the level changes of desired pins (or IRQ's in general) into a
file which can be subsequently viewed using utilities such as \emph{gtkwave}.

ee contains the internal state of the simulated external EEPROM.

\begin{lstlisting}
int main(int argc, char *argv[])
{
    elf_firmware_t f;
    elf_read_firmware("atmega1280_i2ctest.axf", &f);
\end{lstlisting}

The firmware is loaded from the specified file. Note that exactly the same file
can be executed on the AVR hardware without changes. MMCU and frequency
information have been embedded into the binary and are therefore available in
\lstinline|elf_firmware_t|.

\begin{lstlisting}
    avr = avr_make_mcu_by_name(f.mmcu);
    avr_init(avr);
    avr_load_firmware(avr, &f);
\end{lstlisting}

The \lstinline|avr_t| instance is then constructed from the core file of the specified
MMCU, and initialized. The firmware is then copied into the program memory.

\begin{lstlisting}
    i2c_eeprom_init(avr, &ee, 0xa0, 0xfe, NULL, 1024);
    i2c_eeprom_attach(avr, &ee, AVR_IOCTL_TWI_GETIRQ(0));
\end{lstlisting}

\lstinline|AVR_IOCTL_TWI_GETIRQ| is a macro to retrieve the internal IRQ of the TWI
simulation. IRQ's are the main method of communication between simavr and
external components and are also used liberally throughout simavr internals.
Similar macros exist for other important AVR parts such as the ADC, IO ports,
timers, etc.

\begin{lstlisting}
    avr->gdb_port = 1234;
    avr->state = cpu_Stopped;
    avr_gdb_init(avr);
\end{lstlisting}

This section sets up simavr's gdb infrastructure to listen on port 1234. The
CPU is stopped to allow gdb to attach before execution begins.

\begin{lstlisting}
    avr_vcd_init(avr, "gtkwave_output.vcd", &vcd_file, 100000 /* usec */);
    avr_vcd_add_signal(
        &vcd_file,
        avr_io_getirq(avr, AVR_IOCTL_TWI_GETIRQ(0), TWI_IRQ_STATUS),
        8 /* bits */,
        "TWSR");
\end{lstlisting}

Next, a value change dump output is configured to track changes to the
\lstinline|TWI_IRQ_STATUS| IRQ. The file may then be viewed using the \emph{gtkwave}
application.

\begin{lstlisting}
    int state = cpu_Running;
    while ((state != cpu_Done) && (state != cpu_Crashed))
        state = avr_run(avr);

    return 0;
}
\end{lstlisting}

Finally, we have reached the simple main loop. Each iteration executes one
instruction, handles any pending interrupts and cycle timers, and sleeps if
possible. As soon as execution completes or crashes, simulation stops and we
exit the program.

We will now examine the relevant parts of the \lstinline|i2c_eeprom| implementation.
Details have been omitted and only communication with the \lstinline|avr_t| instance are
shown.

\begin{lstlisting}
static const char * _ee_irq_names[2] = {
		[TWI_IRQ_MISO] = "8>eeprom.out",
		[TWI_IRQ_MOSI] = "32<eeprom.in",
};

void
i2c_eeprom_init(
		struct avr_t * avr,
		i2c_eeprom_t * p,
		uint8_t addr,
		uint8_t mask,
		uint8_t * data,
		size_t size)
{

    /* [...] */

	p->irq = avr_alloc_irq(&avr->irq_pool, 0, 2, _ee_irq_names);
	avr_irq_register_notify(p->irq + TWI_IRQ_MOSI, i2c_eeprom_in_hook, p);

    /* [...] */
}
\end{lstlisting}

First, the EEPROM allocates its own private IRQs. The EEPROM implementation
does not know or care to which simavr IRQ's they will be attached. It then
attaches a callback function (\lstinline|i2c_eeprom_in_hook|) to the MOSI IRQ. This
function will be called whenever a value is written to the IRQ. The pointer to
the EEPROM state p is passed to each of these callback function calls.

\begin{lstlisting}
void
i2c_eeprom_attach(
		struct avr_t * avr,
		i2c_eeprom_t * p,
		uint32_t i2c_irq_base )
{
	avr_connect_irq(
		p->irq + TWI_IRQ_MISO,
		avr_io_getirq(avr, i2c_irq_base, TWI_IRQ_MISO));
	avr_connect_irq(
		avr_io_getirq(avr, i2c_irq_base, TWI_IRQ_MOSI),
		p->irq + TWI_IRQ_MOSI );
}
\end{lstlisting}

The private IRQs are then attached to simavr's internal IRQs. This is called
chaining - all messages raised are forwarded to all chained IRQs.

\begin{lstlisting}
static void
i2c_eeprom_in_hook(
		struct avr_irq_t * irq,
		uint32_t value,
		void * param)
{
	i2c_eeprom_t * p = (i2c_eeprom_t*)param;

    /* [...] */

    avr_raise_irq(p->irq + TWI_IRQ_MISO,
            avr_twi_irq_msg(TWI_COND_ACK, p->selected, 1));

    /* [...] */
}
\end{lstlisting}

Finally, we've reached the IRQ callback function. It is responsible for
simulating communications between simavr (acting as the TWI master) and the
EEPROM (as the TWI slave). The EEPROM state which was previously passed to
\lstinline|avr_irq_register_notify| is contained in the param variable and cast back to
an \lstinline|i2c_eeprom_t| pointer for further use.

Outgoing messages are sent by raising the internal IRQ. This message is then
forwarded to all chained IRQs.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Main Loop}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We will now take a closer look at the main loop implementation. Each call to
\lstinline|avr_run| triggers the function stored in the run member of the \lstinline|avr_t| structure
(\lstinline|avr->run|). The two standard implementations are \lstinline|avr_callback_run_raw| and
\lstinline|avr_callback_run_gdb|, located in sim\_avr.c. The essence of both function is
identical; since \lstinline|avr_callback_run_gdb| contains additional logic for GDB
handling (network protocol, stepping), we will examine it further and point out
any differences to the the raw version. Several comments and irrelevant code
sections have been removed.

\begin{lstlisting}
void avr_callback_run_gdb(avr_t * avr)
{
    avr_gdb_processor(avr, avr->state == cpu_Stopped);

    if (avr->state == cpu_Stopped)
        return ;

    int step = avr->state == cpu_Step;
    if (step)
        avr->state = cpu_Running;
\end{lstlisting}

This initial section is gdb specific. \lstinline|avr_gdb_processor| is responsible for
handling GDB network communication. It also checks if execution has reached a
breakpoint or the end of a step and stops the CPU if it did.

If GDB has transmitted a step command, we need to save the state during the
main section of the loop (the CPU ``runs'' for one instruction) and restore to
the ``StepDone'' state at on completion.

\begin{lstlisting}
    avr_flashaddr_t new_pc = avr->pc;

    if (avr->state == cpu_Running) {
        new_pc = avr_run_one(avr);
    }
\end{lstlisting}

We have now reached the actual execution of the current instruction. If the CPU
is currently running, \lstinline|avr_run_one| decodes the instruction located in flash memory
(\lstinline|avr->flash|) and triggers all necessary actions. This can include setting the CPU
state (SLEEP), updating the status register SREG, writing or reading from memory
locations, altering the program counter PC, etc \ldots

Finally, the cycle counter (\lstinline|avr->cycle|) is updated and the new
program counter is returned.

\begin{lstlisting}
    if (avr->sreg[S_I] && !avr->i_shadow)
        avr->interrupts.pending_wait++;
    avr->i_shadow = avr->sreg[S_I];
\end{lstlisting}

This section ensures that interrupts are not triggered immediately when
enabling the interrupt flag in the status register, but with an (additional)
delay of one instruction.

\begin{lstlisting}
    avr_cycle_count_t sleep = avr_cycle_timer_process(avr);
    avr->pc = new_pc;
\end{lstlisting}

Next, all due cycle timers are processed. Cycle timers are one of the
most important and heavily used mechanisms in simavr. A timer allows scheduling
execution of a callback function once a specific count of execution cycles have
passed, thus simulating events which occur after a specific amount of time has
passed. For example, the \lstinline|avr_timer| module uses cycle timers to schedule timer
interrupts.

The returned estimated sleep time is set to the next pending event cycle (or a
hardcoded limit of 1000 cycles if none exist).

\begin{lstlisting}
    if (avr->state == cpu_Sleeping) {
        if (!avr->sreg[S_I]) {
            avr->state = cpu_Done;
            return;
        }
        avr->sleep(avr, sleep);
        avr->cycle += 1 + sleep;
    }
\end{lstlisting}

If the CPU is currently sleeping, the time spent is simulated using the callback
stored in \lstinline|avr->sleep|. In GDB mode, the time is used to listen for
GDB commands, while the raw version simply calls usleep.

It is worth noting that
we have improved the timing behavior by accumulating requested sleep cycles until
a minimum of 200 usec has been reached. usleep cannot handle lower sleep times
accurately, which caused an unrealistic execution slowdown.

A special case occurs when the CPU is sleeping while interrupts are turned off.
In this scenario, there is way of ever waking up. Therefore, execution is halted
gracefully.

\begin{lstlisting}
    if (avr->state == cpu_Running || avr->state == cpu_Sleeping)
        avr_service_interrupts(avr);
\end{lstlisting}

Finally, any immediately pending interrupts are handled. The highest priority
interrupt (this depends solely on the interrupt vector address) is removed from
the pending queue, interrupts are disabled in the status register, and the
program counter is set to the interrupt vector.

If the CPU is sleeping, interrupts can be raised by cycle timers.

\begin{lstlisting}
    if (step)
        avr->state = cpu_StepDone;
}
\end{lstlisting}

Wrapping up, if the current loop iteration was a GDB step, the state is set
such that the next iteration will inform GDB and halt the CPU.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Initialization}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\lstinline|avr_t| Initialization}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The \lstinline|avr_t| struct requires some somple initialization before it is
ready to by used by the main loop as discussed in the previous section.

\lstinline|avr_make_mcu_by_name| fills in all details specific to an MCU. This
includes settings such as memory sizes, register locations, available components,
the default CPU frequency, etc \ldots

The MCU definitions are located in the simavr/cores subdirectory of the simavr
source tree and are compiled conditionally depending on the the local avr-libc
support. A complete list of locally supported cores is printed by running simavr
without any arguments.

On successful completion, it returns a pointer to the \lstinline|avr_t| struct.

If GDB support is desired, \lstinline|avr->gdb_port| must be set, and
\lstinline|avr_gdb_init| must be called to create the required data structures,
set the \lstinline|avr->run| and \lstinline|avr->sleep| callbacks, and listen
on the specified port. It is also recommended to initially stop the cpu
(\lstinline|avr->state = cpu_Stopped|) to delay program execution until it
is started manually by GDB.

Further settings can now be applied manually (typical candidates are logging and
tracing levels).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Firmware}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We now have a fully initialized \lstinline|avr_t| struct and are ready to load
code. This is accomplished using \lstinline|avr_read_firmware|, which uses
elfutils to decode the ELF file and read it into an \lstinline|elf_firmware_t|
struct and \lstinline|avr_load_firmware| to load its contents into the
\lstinline|avr_t| struct.

Besides loading the program code into \lstinline|avr->flash| (and EEPROM contents
into \lstinline|avr->eeprom|, if available), there are several useful extended
features which can be embedded directly into the ELF file.

The target MCU, frequency and voltages can be specified in the ELF file by using the
\lstinline|AVR_MCU| and \lstinline|AVR_MCU_VOLTAGES| macros provided by
avr\_mcu\_section.h:

\begin{lstlisting}
#include "avr_mcu_section.h"
AVR_MCU(16000000 /* Hz */, "atmega1280");
AVR_MCU_VOLTAGES(3300 /* milliVolt */, 3300 /* milliVolt */, 3300 /* milliVolt */);
\end{lstlisting}

VCD traces can be set up automatically. The following code will create an 8-bit
trace on the UDR0 register, and a trace masked to display only the UDRE0 bit of
the UCSR0A register.

\begin{lstlisting}
const struct avr_mmcu_vcd_trace_t _mytrace[]  _MMCU_ = {
    { AVR_MCU_VCD_SYMBOL("UDR0"), .what = (void*)&UDR0, },
    { AVR_MCU_VCD_SYMBOL("UDRE0"), .mask = (1 << UDRE0), .what = (void*)&UCSR0A, },
};
\end{lstlisting}

Several predefined can be sent from the firmware to simavr during program execution.
At the time of writing, these include starting and stopping VCD traces, and putting
UART0 into loopback mode. An otherwise unused register must be specified
to listen for command requests. During execution, writing a command to this
register will trigger the associated action within simavr.

\begin{lstlisting}
AVR_MCU_SIMAVR_COMMAND(&GPIOR0);

int main() {
    /* [...] */
    GPIOR0 = SIMAVR_CMD_VCD_START_TRACE;
    /* [...] */
}
\end{lstlisting}

Likewise, a register can be specified for use as a debugging output. All bytes
written to this register will be output to the console.

\begin{lstlisting}
AVR_MCU_SIMAVR_CONSOLE(&GPIOR0);

int main() {
    /* [...] */
    const char *s = "Hello World\r";
    for (const char *t = s; *t; t++)
        GPIOR0 = *t;
    /* [...] */
}
\end{lstlisting}

Usually, UART0 is used for this purpose. The simplest debug output can be achieved
by binding \lstinline|stdout| to \lstinline|UART0| as described by the avr-libc
documentation \cite{libc}, and then using \lstinline|printf| and co. This alternate console
output is provided in case using UART0 is not possible or desired.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Instruction Processing}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We have now covered \lstinline|avr_t| initialization, the main loop, and loading
firmware files. But how are instructions actually decoded and executed? Let's
take a look at \lstinline|avr_run_one|, located in sim\_core.

The opcode is reconstructed by retrieving the two bytes located at
\lstinline|avr->flash[avr->pc]|. \lstinline|avr->pc| points to the LSB, and
\lstinline|avr->pc + 1| to the MSB. Thus, the full opcode is reconstructed with:

\begin{lstlisting}
uint32_t opcode = (avr->flash[avr->pc + 1] << 8) | avr->flash[avr->pc];
\end{lstlisting}

As we have seen, \lstinline|avr->pc| represents the byte address in flash memory.
Therefore, the next instruction is located at \lstinline|avr->pc + 2|. This
default new program counter may still be altered in the course of processing
in case of jumps, branches, calls and larger opcodes such as STS\cite{instructionset}.

Note also that the AVR flash addresses are usually represented as word addresses
(\lstinline|avr->pc >> 1|).

Similar to the program counter, the spent cycles are set to a default value of 1.

The instruction and its operands are then extracted from the opcode and processed
in a large switch statement. The instructions themselves can be roughly categorized
into arithmetic and logic instructions, branch instructions, data transfer
instructions, bit and bit-test instructions and MCU control instructions.

Processing these will involve a number of typical tasks:

\begin{itemize}
\item Status register modifications

The status register is stored in \lstinline|avr->sreg| as a byte array.
Most instructions alter the SREG in some way, and convenience functions such as
\lstinline|get_compare_carry| are used to ease this task. Note that whenever the
firmware reads from SREG, it must be reconstructed from \lstinline|avr->sreg|.

\item Reading or writing memory

\lstinline|_avr_set_ram| is used to write bytes to a specific address. Accessing
an SREG will trigger a reconstruction similar to what has been discussed above.
IO register accesses trigger any connected IO callbacks and raise all associated
IRQs. If a GDB watchpoint has been hit, the CPU is stopped and a status report
is sent to GDB. Data watchpoint support has been added by the author.

\item Modifying the program counter

Jumps, skips, calls, returns and similar instructions alter the program counter.
This is achieved by simply setting \lstinline|new_pc| to an appropriate value. Care must be
taken to skip 32 bit instructions correctly.

\item Altering MCU state

Instructions such as SLEEP and BREAK directly alter the state of the simulation.

\item Stack operations

Pushing and popping the stack involve altering the stack pointer in addition
to the actual memory access. 
\end{itemize}

Upon conclusion, \lstinline|avr->cycle| is updated with the actual instruction
duration, and the new program counter is returned.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Interrupts}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

An interrupt is an asynchronous signal which causes the the \ac{CPU} to jump to
the associated \ac{ISR} and continue execution there.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Cycle Timers}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{GDB}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{IRQs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{IO}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{VCD}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example of an internal module implementation} %TODO
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Embedding MCU Information in Binaries}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Core Definitions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% = eof =====================================================================
%%
