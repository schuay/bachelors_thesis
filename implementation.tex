%%
%% Implementation
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation} \label{chapter:implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We will now examine the actual implementation of \qsimavr and how its individual
parts work together, beginning with the core, the component interface,
a short walkthrough of all components, and finally brief descriptions of the
modifications and additions made to \simavr during the course of this thesis.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\qsimavr Core} \label{section:core}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The core of \qsimavr is located in the \verb|QSimAVR/| subfolder of the source
tree. Its responsibilities include handling the routine tasks of the main window
(including menu and action handling, status bar updates, displaying ``File Open''
dialogs when loading firmware, etc \ldots), loading and subsequently managing
plugins, and actually running the \simavr main loop.

In the following sections, we will discuss the interesting parts of the
\lstinline|SimAVR| and \lstinline|PluginManager| classes. Interested readers
should consult the source code for complete implementation details.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\lstinline|SimAVR|} \label{subsection:class_simavr}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The \lstinline|SimAVR| class encapsulates the \lstinline|avr_t| instance. It
runs in its own thread by subclassing \lstinline|QThread| and being started
with the \lstinline|start()| function.

\begin{lstlisting}
class SimAVR : public QThread
{
    Q_OBJECT

public:
    SimAVR();
    virtual ~SimAVR();

    void load(const QString &filename);
    void run();

public slots:
    void pauseSimulation();
    void stopSimulation();
    void attachGdb();

private:
    avr_t *avr;

    /* [...] */
};
\end{lstlisting}

\lstinline|SimAVR| can load firmware, initialize the \lstinline|avr_t| instance,
and execute its main loop:

\begin{lstlisting}
int state;
uint8_t i = 0;
do {
    state = avr_run(avr);
    if (i++ == 0) {
        QCoreApplication::processEvents();
    }
} while (state != cpu_Done && state != cpu_Crashed);
emit simulationStateChanged(Done);
\end{lstlisting}

The loop itself is very similar to ones we have already seen in section
\ref{section:simavr_example_walkthrough}; additionally, since we heavily use
queued signals, we need to call \lstinline|processEvents| to allow the internal
Qt event handler to forward signals. However, profiling sessions have shown
\lstinline|processEvents| to require an unacceptable amount of processing time
when called each loop iteration - it appears that every call will require at least
one mutex lock and unlock cycle. For performance reasons, we therefore limited
event processing to occur only once every $2^8$ iterations.\footnote{
%
This is also somewhat less than ideal when using \ac{GDB} for short steps, since
results will only be visible with an average delay of $2^7$ iterations.
%
}
Changes in simulation state are in turn
emitted as signals (which are then processed by \lstinline|MainWindow| and
displayed in the status bar).

\lstinline|SimAVR| also provides functions for pausing, unpausing and stopping the
simulation, and for preparing \simavr to listen to incoming \ac{GDB} connections.
Each of these operations also results in changes to the simulation state.

Whenever a firmware is loaded or unloaded, signals are emitted and processed
by \lstinline|PluginManager| to respectively connect and disconnect components
from the \lstinline|avr_t| instance.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\lstinline|PluginManager|}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The plugin manager

\begin{itemize}
\item Can load components from shared libraries,
\item Creates \ac{MDI} sub-windows within the main \lstinline|QMdiArea| as needed,
\item Manages their connections to \lstinline|avr_t| instances as plugins are
      enabled or disabled and simulation is restarted or loaded with a new firmware
      file,
\item Turns \ac{VCD} tracing on depending on the selections made in component
      settings, and
\item Saves and restores component settings.
\end{itemize}

Loading plugins is implemented such that files in a specific directory (which can be
set during installation, see section \ref{section:setup_qsimavr}) are iterated
one by one. If loading a file fails, an error message is printed to the log targets
and loading continues with the next file. Each component must adhere to the
component interface (see section \ref{subsection:component_interface}) and contain
the plugin registration function.
It is also possible to keep components
in different directories, only placing symlinks (symbolic links) into
\lstinline|PLUGINDIR|.

\begin{lstlisting}
QLibrary lib(filename);
RegisterFunction registerPlugin = (RegisterFunction)lib.resolve(PUBLISH_FNAME);

QSharedPointer<ComponentFactory> factory(registerPlugin());
\end{lstlisting}

Component registration uses the \lstinline|QLibrary| class to load the shared library,
and then creates a factory instance by calling the \lstinline|registerPlugin|
function common to each component.

The factory then creates the actual logic and \ac{GUI} parts. If a \ac{GUI} part
exists, a \lstinline|QMdiSubWindow| is created containing the component's widget.
The logic part is moved to the \lstinline|SimAVR| thread.

Whenever \lstinline|firmwareLoaded| or \lstinline|firmwareUnloaded| signal is sent
by \lstinline|SimAVR|, the logic part of components is, respectively, connected
or disconnected from the \lstinline|avr_t| instance.

Component settings are saved and loaded using the Qt's \lstinline|QSettings|
class, which provides a simple and cross-platform method of handling settings
files.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Component Interface} \label{subsection:component_interface}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Each component must implement the component interface defined in
\verb|QSimAVR/component.h|. It consists of factory, \ac{GUI} and logic classes,
and a \lstinline|registerPlugin| function which returns a factory instance. Let's
take a look at each of these:

\begin{lstlisting}
template<typename Interface>
class Factory {
public:
    Factory() { }
    virtual Interface create() = 0;
    virtual ~Factory() { }

private:
    Q_DISABLE_COPY(Factory)
};

typedef Factory<Component> ComponentFactory;
\end{lstlisting}

The factory is a generic class which simply provides a pure abstract \lstinline|create| function
to create, initialize and return an object. In \qsimavr, we only use the instatiated
version \lstinline|ComponentFactory|, which returns a \lstinline|Component|.

\lstinline|Q_DISABLE_COPY| prevents copying a class by declaring the copy and
assignment constructors in the private section:

\begin{lstlisting}
#define Q_DISABLE_COPY(Class) \
    Class(const Class &); \
    Class &operator=(const Class &);
\end{lstlisting}

In practice, \lstinline|ComponentFactory::create| constructs all parts of a component, connects
their signals and slots\footnote{
%
It is particularly important to realize that these must use queued signal
delivery, since the logic and \ac{GUI} parts do not reside in the same thread.
Specify \lstinline|Qt::QueuedConnection| in \lstinline|QObject::connect()|.
%
} and packs them into a \lstinline|Component|, which is simply a struct containing
smart pointers to the component parts:

\begin{lstlisting}
struct Component
{
    QSharedPointer<ComponentGui> gui;
    QSharedPointer<ComponentLogic> logic;
};
\end{lstlisting}

The \ac{GUI} part of a component provides a method for the user to interact with
the plugin by both displaying component state and allowing user input.

\begin{lstlisting}
class ComponentGui
{
public:
    ComponentGui() { }

    virtual QWidget *widget() = 0;
    virtual ~ComponentGui() { }

private:
    Q_DISABLE_COPY(ComponentGui)
};
\end{lstlisting}

Its interface is very simple; communication with the logic part is handled internally
by signals, and user interaction is handled by the widget itself. The
\lstinline|QWidget| is displayed as the central widget in a \lstinline|QMdiSubWindow|.
Most of the time, the functionality provided by a \ac{GUI} component is simple enough
such that it can inherit both from \lstinline|ComponentGui| and \lstinline|QWidget|
itself\footnote{
%
Therefore, \lstinline|ComponentGui::widget| can simply return the
\lstinline|this| pointer.
%
}.

The logic part encapsulates a component's internal state; it also reacts to signals,
communicates with it's \ac{GUI}, and is responsible for accurately simulating
the behavior of the actual component.

\begin{lstlisting}
class ComponentLogic : public QObject
{
public:
    ComponentLogic(QObject *parent = NULL);
    virtual ~ComponentLogic() { }

    virtual void wire(avr_t *avr);
    virtual void unwire();
    virtual void enableVcd(bool vcdEnabled);

protected:
    virtual void wireHook(avr_t *avr) = 0;
    virtual void unwireHook() = 0;
    virtual void resetHook() { }

protected:
    bool connected;
    bool vcdEnabled;

    avr_vcd_t vcdFile;

    struct component_io_t {
        avr_io_t io;
        ComponentLogic *instance;
    } io;

private:
    static void resetHookPrivate(avr_io_t *io);

private:
    Q_DISABLE_COPY(ComponentLogic)
};
\end{lstlisting}

Common functionality is handled in \lstinline|ComponentLogic| itself by implementing
it in the public function, which then calls a private hook at an appropriate time
(for example, see \lstinline|wire| and \lstinline|wireHook|).

\lstinline|wire| connects a component to the \lstinline|avr_t| instance. Most of
the time, this involves creating internal \acp{IRQ}, connecting them to the
desired target \acp{IRQ}, setting up notification callbacks, and defining the
signals traced by a \ac{VCD}.

Callback functions require a little extra work because \simavr is written in plain
C and has no notion of classes or member functions. A simple solution to this problem
is to register a static class function as the callback, pass \lstinline|this| as
the callback \lstinline|param|, and let the static function execute the actual member
function. A typical example (taken from the temperature component):

\begin{lstlisting}
void TemperatureLogic::wireHook(avr_t *avr)
{
    /* [...] */
    avr_irq_register_notify(irq + IRQ_TEMP_DQ, TemperatureLogic::pinChangedHook, this);
    /* [...] */
}

void TemperatureLogic::pinChangedHook(avr_irq_t *, uint32_t value, void *param)
{
    TemperatureLogic *p = (TemperatureLogic *)param;
    p->pinChanged(value);
}
\end{lstlisting}

\lstinline|enableVcd| simply toggles \ac{VCD} traces on and off. A default implementation
is provided in \lstinline|ComponentLogic| itself.

Again, supporting \simavr
\ac{VCD} traces has an interesting quirk; as explained in section \ref{section:vcd_files},
\ac{VCD} files depend upon \simavr cycle timers\footnote{
%
See section \ref{section:cycle_timers}.
%
}, which are transient and deleted entirely when \lstinline|avr_reset| is called.
We therefore require a way to recreate cycle timers on each reset. This functionality
is provided the \lstinline|avr_io_t| module (section \ref{subsection:avr_io_t}),
or more specifically, its \lstinline|reset| callback. Each component is registered
with the \lstinline|avr_t| core as such a module. On each reset event,
\ac{VCD} connections are automatically restored, and the (optional)
\lstinline|ComponentLogic::resetHook| of every component is called for any
custom setup steps.

The final piece of the \lstinline|Component| interface is the registration function.
Plugins must declare themselves using the \lstinline|PUBLISH_PLUGIN| macro,
which defines a C function returning a factory instance:

\begin{lstlisting}
#define PUBLISH_PLUGIN(factory) \
    extern "C" { \
        ComponentFactory *registerPlugin() { return new factory; } \
    }
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\acf{TWI} Component} \label{section:component_twi}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We now turn our attention to the actual component implementations. The \ac{TWI}
component is actually not a component as defined by the component interface in
section \ref{subsection:component_interface}; rather, it is a library providing
helper functions for other components acting as a slave
using the \ac{TWI} protocol\footnote{
%
The \ac{TWI} component compiles into a static library which can be included
by any other component requiring it.
%
}.

To prevent duplicate work and the \ac{NIH} syndrome\footnote{
%
For programmers, laziness is a virtue.
%
}, the \ac{TWI} implementation is an adaption of the work done by the \simavr
author in the \verb|i2c_eeprom| component. The \ac{TWI} slave logic was extracted
into a separate library because it is needed by both the \ac{EEPROM}
(section \ref{section:component_eeprom}) and \ac{RTC} (section \ref{section:component_rtc})
components.

We simply connect ourselves to the \lstinline|TWI_IRQ_MISO| and \lstinline|TWI_IRQ_MOSI|
\acp{IRQ}, process incoming and outgoing messages according to the \ac{TWI}
protocol, and notify interested parties when we've either received a complete message,
or we need to send data to the \ac{TWI} master.

For that purpose, a \lstinline|TwiSlave| interface is defined which components
using \lstinline|TwiComponent| must implement.

\begin{lstlisting}
class TwiSlave
{
public:
    virtual uint8_t transmitByte() = 0;
    virtual bool matchesAddress(uint8_t address) = 0;
    virtual void received(const QByteArray &data) = 0;
};
\end{lstlisting}

\lstinline|transmitByte| is called by the \ac{TWI} component whenever the master
begins a read transaction and returns the next byte to send.
\lstinline|matchesAddress| returns true, \ac{iff} the slave address matches
the address sent by the master or if the general call address (\lstinline|0x0|)
has been sent.
\lstinline|received| is called with the received data once a write transaction
completes, and allows the slave to react to a transmission.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\acf{EEPROM} Component} \label{section:component_eeprom}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The \ac{EEPROM} uses the \ac{TWI} component briefly described in section \ref{section:component_twi}.
It has been implemented using the datasheet \cite{microchip01} as a reference.
The simulated \ac{EEPROM} consists of 1 kbit of storage and is controlled over a
\ac{TWI} bus.

The implementation itself is very simple since the \ac{TWI} logic is encapsulated
by the \ac{TWI} component. We can therefore look at the \ac{EEPROM} from a very
high level, and are only interested in keeping track of the \ac{AP} and the state
of the internal memory. Reading from the \ac{EEPROM} returns the byte pointed to
by the \ac{AP} and then increments the \ac{AP}. Similarly, writing data section
writes it to the \ac{AP} and subsequently increments it.

This functionality is achieved by implementing the \lstinline|TwiSlave| methods
as follows (edited for clarity):

\begin{lstlisting}
uint8_t EepromLogic::transmitByte()
{
    return eeprom[incrementAddress()];
}

void EepromLogic::received(const QByteArray &data)
{
    addressPointer = data[0];
    for (int i = start; i < data.size(); i++) {
        eeprom[incrementAddress()] = data[i];
    }
}

bool EepromLogic::matchesAddress(uint8_t address)
{
    return ((address & EEPROM_MASK) == (EEPROM_ADDR & EEPROM_MASK) ||
            (address & 0xfe) == 0x00);
}
\end{lstlisting}

The \lstinline|QByteArray| is used to represent the byte storage internally as it
provides both the convenience of many helper functions, and the advantages
of raw memory arrays through \lstinline|QByteArray::data|.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\acf{RTC} Component} \label{section:component_rtc}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The \ac{RTC} component consists of a 56 byte memory area\footnote{
%
8 of which are used to represent clock state, with the rest usable as generic
storage.
%
}, communications over a \ac{TWI} bus, and timekeeping logic which updates its
clock registers once per second \cite{maxim01}.

Internally, the implementation is very similar to the \ac{EEPROM} examined in section
\ref{section:component_eeprom}; so much in fact, that only differences to the \ac{EEPROM}
will be discussed here. Writing and reading from the memory storage is identical.

The first 7 bytes represent the clock's date and time in \ac{BCD} format and need
to be updated periodically to reflect the passing of time. Once again,
\simavr's cycle timers (discussed in section \ref{section:cycle_timers}) came in
handy to achieve the desired functionality. A callback is registered to occur
once every second (of simulated time), which updates the the date
and time bytes. Handling of leap years is simplified by relying on Qt's
\lstinline|QDate| class.

The square wave pin of the actual component is \emph{not} implemented.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\acf{GLCD} Component}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cite{winstar01, samsung01, neotec01}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\acf{LCD} Component}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cite{hitachi01, samsung02, winstar02}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\acf{LED} Buttons Component}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Temperature Sensor Component}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cite{maxim02}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Changes and additions to \simavr}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
