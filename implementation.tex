%%
%% Implementation
%%

\chapter{Implementation} \label{chapter:implementation}

We will now examine the actual implementation of \qsimavr and how its individual
parts work together, beginning with the core, the component interface,
a short walkthrough of all components, and finally brief descriptions of the
modifications and additions made to \simavr during the course of this thesis.

\section{\qsimavr Core} \label{section:core}

The core of \qsimavr is located in the \verb|QSimAVR/| subfolder of the source
tree. Its responsibilities include handling the routine tasks of the main window
(including menu and action handling, status bar updates, displaying ``File Open''
dialogs when loading firmware, etc \ldots), loading and subsequently managing
plugins, and actually running the \simavr main loop.

In the following sections, we will discuss the interesting parts of the
\lstinline|SimAVR| and \lstinline|PluginManager| classes. Interested readers
should consult the source code for complete implementation details.

\subsection{\lstinline|SimAVR|} \label{subsection:class_simavr}

The \lstinline|SimAVR| class encapsulates the \lstinline|avr_t| instance. It
runs in its own thread by subclassing \lstinline|QThread| and being started
with the \lstinline|start()| function.

\begin{lstlisting}
class SimAVR : public QThread
{
    Q_OBJECT

public:
    SimAVR();
    virtual ~SimAVR();

    void load(const QString &filename);
    void run();

public slots:
    void pauseSimulation();
    void stopSimulation();
    void attachGdb();

private:
    avr_t *avr;

    /* [...] */
};
\end{lstlisting}

\lstinline|SimAVR| can load firmware, initialize the \lstinline|avr_t| instance,
and execute its main loop:

\begin{lstlisting}
int state;
uint8_t i = 0;
do {
    state = avr_run(avr);
    if (i++ == 0) {
        QCoreApplication::processEvents();
    }
} while (state != cpu_Done && state != cpu_Crashed);
emit simulationStateChanged(Done);
\end{lstlisting}

The loop itself is very similar to ones we have already seen in section
\ref{section:simavr_example_walkthrough}; additionally, since we heavily use
queued signals, we need to call \lstinline|processEvents| to allow the internal
Qt event handler to forward signals. However, profiling sessions have shown
\lstinline|processEvents| to require an unacceptable amount of processing time
when called each loop iteration - it appears that every call will require at least
one mutex lock and unlock cycle. For performance reasons, we therefore limited
event processing to occur only once every $2^8$ iterations.\footnote{
%
This is also somewhat less than ideal when using \ac{GDB} for short steps, since
results will only be visible with an average delay of $2^7$ iterations.
%
}
Changes in simulation state are in turn
emitted as signals (which are then processed by \lstinline|MainWindow| and
displayed in the status bar).

\lstinline|SimAVR| also provides functions for pausing, unpausing and stopping the
simulation, and for preparing \simavr to listen to incoming \ac{GDB} connections.
Each of these operations also results in changes to the simulation state.

Whenever a firmware is loaded or unloaded, signals are emitted and processed
by \lstinline|PluginManager| to respectively connect and disconnect components
from the \lstinline|avr_t| instance.

\section{\lstinline|PluginManager|}

The plugin manager

\begin{itemize}
\item Can load components from shared libraries,
\item Creates \ac{MDI} sub-windows within the main \lstinline|QMdiArea| as needed,
\item Manages their connections to \lstinline|avr_t| instances as plugins are
      enabled or disabled and simulation is restarted or loaded with a new firmware
      file,
\item Turns \ac{VCD} tracing on depending on the selections made in component
      settings, and
\item Saves and restores component settings.
\end{itemize}

Loading plugins is implemented such that files in a specific directory (which can be
set during installation, see section \ref{section:setup_qsimavr}) are iterated
one by one. If loading a file fails, an error message is printed to the log targets
and loading continues with the next file. Each component must adhere to the
component interface (see section \ref{section:component_interface}) and contain
the plugin registration function.
It is also possible to keep components
in different directories, only placing symlinks (symbolic links) into
\lstinline|PLUGINDIR|.

\begin{lstlisting}
QLibrary lib(filename);
RegisterFunction registerPlugin = (RegisterFunction)lib.resolve(PUBLISH_FNAME);

QSharedPointer<ComponentFactory> factory(registerPlugin());
\end{lstlisting}

Component registration uses the \lstinline|QLibrary| class to load the shared library,
and then creates a factory instance by calling the \lstinline|registerPlugin|
function common to each component.

The factory then creates the actual logic and \ac{GUI} parts. If a \ac{GUI} part
exists, a \lstinline|QMdiSubWindow| is created containing the component's widget.
The logic part is moved to the \lstinline|SimAVR| thread.

Whenever \lstinline|firmwareLoaded| or \lstinline|firmwareUnloaded| signal is sent
by \lstinline|SimAVR|, the logic part of components is, respectively, connected
or disconnected from the \lstinline|avr_t| instance.

Component settings are saved and loaded using the Qt's \lstinline|QSettings|
class, which provides a simple and cross-platform method of handling settings
files.

\section{Component Interface} \label{section:component_interface}

Each component must implement the component interface defined in
\verb|QSimAVR/component.h|. It consists of factory, \ac{GUI} and logic classes,
and a \lstinline|registerPlugin| function which returns a factory instance. Let's
take a look at each of these:

\begin{lstlisting}
template<typename Interface>
class Factory {
public:
    Factory() { }
    virtual Interface create() = 0;
    virtual ~Factory() { }

private:
    Q_DISABLE_COPY(Factory)
};

typedef Factory<Component> ComponentFactory;
\end{lstlisting}

The factory is a generic class which simply provides a \lstinline|create| function
to create, initialize and return an object. In \qsimavr, we only use the instatiated
version \lstinline|ComponentFactory|, which returns a \lstinline|Component|.

\section{\acf{TWI} Component}

\section{\acf{EEPROM} Component}

\cite{microchip01}

\section{\acf{RTC} Component}

\cite{maxim01}

\section{\acf{GLCD} Component}

\cite{winstar01, samsung01, neotec01}

\section{\acf{LCD} Component}

\cite{hitachi01, samsung02, winstar02}

\section{\acf{LED} Buttons Component}

\section{Temperature Sensor Component}

\cite{maxim02}

\section{Changes and additions to \simavr}
